import h5py
from labscript import set_passed_properties, LabscriptError, TriggerableDevice
from labscript_devices.IMAQdxCamera.labscript_devices import IMAQdxCamera
from labscript_utils import dedent
import numpy as np
import sys
from enum import Enum
from typing import Optional
from pyqtgraph.examples.ScatterPlotSpeedTest import param
from user_devices.logger_config import logger


class TriggerEdgeType(str, Enum):
    RISING = "RisingEdge"
    FALLING = "FallingEdge"
    BOTH = "AnyEdge"
    HIGH = "LevelHigh"
    LOW = "LevelLow"

class VisibilityLevelType(str, Enum):
    SIMPLE = 0 # Beginner
    INTERMEDIATE = 1 # Expert
    ADVANCED = 2 # Guru

class IDS_UICamera(TriggerableDevice):
    """In buffered mode (during a shot), the camera captures frames only upon receiving an external trigger.
    Since there is no parent control device, the trigger is not generated by the system — it arrives independently.
    However, we can still define how many triggers (and therefore frames) should be captured during a single shot.
    In each expose(), we specify the names of these frames. And the number of expose() calls specify the number of frames to capture. """
    @set_passed_properties(
        property_names={
            "connection_table_properties":[
                "serial_number",
                "name",
                "orientation"
            ],
            "device_properties":[
                "camera_attributes",
                "trigger_activation",
                "visibility",
                "acquisition_timeout",
                "exception_on_failed_shot",
                "trigger_delay",
            ]
        }
    )
    def __init__(self, name, trigger_activation_type:TriggerEdgeType=TriggerEdgeType.FALLING, serial_number=None, connection=None, parent_device=None, parentless=True,
                 exposure_time=None, frame_rate_fps=None, gain=None, roi=None, visibility_level: Optional[VisibilityLevelType]=VisibilityLevelType.SIMPLE,
                 acquisition_timeout=None, orientation=None, exception_on_failed_shot=True, trigger_delay=0.0, **kwargs):
        """

        :param name:
        :param trigger_activation_type:
        :param serial_number:
        :param connection:
        :param parent_device:
        :param parentless:
        :param exposure_time: in seconds
        :param frame_rate_fps:
        :param gain:
        :param roi:
        :param visibility_level: The detail level of the camera attributes saved to the HDF5 file at the
                end of each shot. If None, no attributes will be saved. If `None`, no attributes will be saved.
        :param exception_on_failed_shot (bool), default: `True`.
                If acquisition does not complete within the given timeout after the end
                of a shot, whether to raise an exception. If False, instead prints a
                warning to stderr (visible in the terminal output pane in the BLACS
                tab), saves the images acquired so far, and continues. In the case of
                such a 'failed shot', the HDF5 attribute
                f['images'][orientation/name].attrs['failed_shot'] will be set to `True`
                (otherwise it is set to `False`). This attribute is acessible in the
                lyse dataframe as `df[orientation/name, 'failed_shot']`.

        :param acquisition_timeout: timeout in seconds
        :param kwargs:
        """

        if serial_number is not None and not isinstance(serial_number, str):
            raise ValueError("The 'serial_number' attribute must be of type str")
        self.serial_number = serial_number

        self.BLACS_connection = self.serial_number

        self.camera_attributes = {}
        if exposure_time is not None:
            self.camera_attributes['exposure_time_ms'] = exposure_time
        if frame_rate_fps is not None:
            self.camera_attributes['frame_rate_fps'] = frame_rate_fps
        if gain is not None:
            self.camera_attributes['gain'] = gain
        if roi is not None:
            if not isinstance(roi, (tuple, list)) or len(roi) != 4:
                raise ValueError("ROI must be a tuple of 4 elements: (x_offset, y_offset, width, height)")
            x_offset, y_offset, width, height = roi
            if not (1 <= width <= 1280 and 1 <= height <= 1024):
                raise ValueError("ROI dimensions out of range: width ≤ 1280, height ≤ 1024")
            self.camera_attributes['roi']  = roi # a tuple

        self.visibility = visibility_level.value if visibility_level else None
        self.trigger_activation = trigger_activation_type.value
        self.acquisition_timeout = acquisition_timeout
        self.orientation = orientation
        self.exception_on_failed_shot = exception_on_failed_shot
        self.trigger_delay = trigger_delay
        self.exposures = []

        TriggerableDevice.__init__(self, name, parent_device, connection, parentless, **kwargs)

    def expose(self, name, frametype='frame'):
        """Specifies the frame names and types. """
        self.exposures.append((name, frametype))


    def generate_code(self, hdf5_file):
        # Create dataset
        dtype = np.dtype([('name', h5py.string_dtype()),
                          ('frametype', h5py.string_dtype())])

        data = np.array(self.exposures, dtype=dtype)
        group = self.init_device_group(hdf5_file)
        if self.exposures:
            group.create_dataset('EXPOSURES', data=data)


        logger.info("exposures: %s", self.exposures)
